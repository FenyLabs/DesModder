# Replacements for Performance Info

*plugin* `performance-info`

Might update symbol binding to shorten this, current workaround is to spam blocks

## Store initial time

*Module* `core/math/context`

*Find* => `defineNow`
```js
var $now =
  'undefined' != typeof performance
    ? function () {
        return performance.now()
      }
    : function () {
        return Date.now()
      }
```

*Replace* `defineNow` with
```js
var $now =
  ((function () {
    let sendMessage = (message) => {
      self.postMessage({
        DesModder: true,
        plugin: "performance-info",
        message: message,
      });
    };
    let workerStart = performance.now();
    let tempStart;
    self._dsm = { sendMessage, workerStart, tempStart };
  })(),
  "undefined" != typeof performance
    ? function () {
        return performance.now();
      }
    : function () {
        return Date.now();
      })
```

## Send message when updateAnalysis is done

*Module* `core/math/context`

*Find* => `updateAnalysis`
```js
$timingData.updateAnalysis = $end - $start
```

*Replace* `updateAnalysis` with
```js
($timingData.updateAnalysis = $end - $start),
  self._dsm.sendMessage({
    type: "log-evaluation-step-timing",
    step: "updateAnalysis",
    timing: [$start, $end],
    workerStart: self._dsm.workerStart,
  })

```

## Send message when graphAllChanges is done

*Module* `core/math/context`

*Find* => `graphAllChanges`
```js
$timingData.graphAllChanges = $end - $start
```

*Replace* `graphAllChanges` with
```js
($timingData.graphAllChanges = $end - $start),
  self._dsm.sendMessage({
    type: "log-evaluation-step-timing",
    step: "graphAllChanges",
    timing: [$start, $end],
    workerStart: self._dsm.workerStart,
  }),
  $start = ($timingData, $end)
```

## Send message when processEvents is done

Also fixes vanilla bug where processEvents is not included in timeInWorker

*Module* `core/math/context`

*Find* => `processEvents`
```js
$start = ($timingData, $end);
var $eventUpdates = this.processEvents($changeSet.events)
```

*Replace* `processEvents` with
```js
$start = $end;
var $eventUpdates = this.processEvents($changeSet.events);
$end = performance.now();
$timingData.processEvents = $end - $start;
self._dsm.sendMessage({
  type: "log-evaluation-step-timing",
  step: "graphAllChanges",
  timing: [$start, $end],
  workerStart: self._dsm.workerStart,
});
```

## Log individual expression timing for analysis

*Module* `core/math/context`

*Find* => `analyzeExpression`
```js
$analysis[$id] = this.statements[$id].analyze(this.policy, $frame, $analysis),
    $analysis[$id].exportTo(this.policy, $frame)
```

*Replace* `analyzeExpression` with
```js
((self._dsm.tempStart = performance.now()),
  ($analysis[$id] = this.statements[$id].analyze(
    this.policy,
    $frame,
    $analysis
  )),self._dsm.sendMessage({
    type: "log-expression-timing",
    step: "analyzeExpression",
    timing: [self._dsm.tempStart, performance.now()],
    id: $id,
    workerStart: self._dsm.workerStart,
  }),
  $analysis[$id].exportTo(this.policy, $frame))
```

## Log individual expression timing for graphing

*Module* `core/math/context`

*Find* => `graphExpression`
```js
this._notifyGraphComputed(
  $index,
  $analysis.graph(
    $viewport,
    this.childIntersections.getChildIntersections($index)
  ),
  $data
)
```

*Replace* `graphExpression` with
```js
this._notifyGraphComputed(
  $index,
  (() => {
    let tempStart = performance.now();
    let result = $analysis.graph(
      $viewport,
      this.childIntersections.getChildIntersections($index)
    );
    self._dsm.sendMessage({
      type: "log-expression-timing",
      step: "graphAllChanges",
      timing: [tempStart, performance.now()],
      id: $index,
      workerStart: self._dsm.workerStart,
    });
    return result;
  })(),
  $data
)
```